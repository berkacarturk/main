from kivy.app import App
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.button import Button
from kivy.uix.togglebutton import ToggleButton
from kivy.uix.label import Label
from kivy.graphics import Color, Ellipse, Line, Triangle, InstructionGroup,Rectangle
from kivy.core.window import Window
from kivy.uix.widget import Widget
from kivy.clock import Clock
import random
from kivy.config import Config
from kivy.uix.slider import Slider
import serial
import json 
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.gridlayout import GridLayout
import threading
from collections import deque

class ArrowButton(Button):
    def __init__(self, direction, label_text, **kwargs):
        super().__init__(**kwargs)
        self.direction = direction
        self.text = label_text
        self.font_size = 24
        self.background_normal = ''
        self.background_color = (0, 0, 0, 0)
        self.size_hint = (None, None)
        self.size = (80, 80)

        with self.canvas.before:
            self.bg_color = Color(0.545, 0.133, 0.196)
            self.bg_circle = Ellipse(pos=self.pos, size=self.size)

        self.bind(pos=self.update_graphics, size=self.update_graphics)
        self.canvas_instruction = InstructionGroup()
        self.canvas.add(self.canvas_instruction)

        self.bind(on_press=self.on_arrow_press)

    def on_arrow_press(self, instance):
        print(f"{self.text}")
        # Ana ekrana erişip veri gönder
        parent = self.parent
        while parent and not hasattr(parent, 'send_to_arduino'):
            parent = parent.parent
        if parent and hasattr(parent, 'send_to_arduino'):
            parent.send_to_arduino(f"{self.text}")

    def on_arrow_release(self, instance):
        parent = self.parent
        while parent and not hasattr(parent, 'send_to_arduino'):
            parent = parent.parent
        if parent and hasattr(parent, 'send_to_arduino'):
            if "X" in self.text:
                parent.send_to_arduino("STOPX")
            elif "Y" in self.text:
                parent.send_to_arduino("STOPY")

    def update_graphics(self, *args):
        self.bg_circle.pos = self.pos
        self.bg_circle.size = self.size

        self.canvas_instruction.clear()
        self.canvas_instruction.add(Color(0.851, 0.851, 0.851))
        cx, cy = self.center
        s = 25
        if self.direction == 'up':
            self.canvas_instruction.add(Triangle(points=[cx, cy + s, cx - s, cy - s, cx + s, cy - s]))
        elif self.direction == 'down':
            self.canvas_instruction.add(Triangle(points=[cx, cy - s, cx - s, cy + s, cx + s, cy + s]))
        elif self.direction == 'left':
            self.canvas_instruction.add(Triangle(points=[cx - s, cy, cx + s, cy - s, cx + s, cy + s]))
        elif self.direction == 'right':
            self.canvas_instruction.add(Triangle(points=[cx + s, cy, cx - s, cy - s, cx - s, cy + s]))

class GyroDisplay(Widget):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.gyro_x = 0
        self.gyro_y = 0
        
        # PERFORMANS OPTİMİZASYONU - Veri değişmediğinde çizim yapma
        self.last_x = None
        self.last_y = None
        self.update_threshold = 0.1  # Minimum değişim miktarı
        
        # İlk başta su terazisini çiz
        Clock.schedule_once(self.update_display, 0.1)
        
    def update_gyro_data(self, gyro_x, gyro_y):
        # PERFORMANS: Sadece önemli değişikliklerde güncelle
        if (self.last_x is None or 
            abs(gyro_x - self.last_x) > self.update_threshold or 
            abs(gyro_y - self.last_y) > self.update_threshold):
            
            self.gyro_x = gyro_x
            self.gyro_y = gyro_y
            self.last_x = gyro_x
            self.last_y = gyro_y
            self.update_display()
        
    def update_display(self, *args):
        self.canvas.clear()
        with self.canvas:
            # Daire halkaları
            Color(0.8, 0.8, 0.8)
            for r in [20, 40, 60]:
                Line(circle=(self.center_x, self.center_y, r), width=1.2)
            
            # Merkez çizgiler
            Color(0.6, 0.6, 0.6)
            Line(points=[self.center_x - 70, self.center_y, self.center_x + 70, self.center_y], width=1)
            Line(points=[self.center_x, self.center_y - 70, self.center_x, self.center_y + 70], width=1)
            
            # HASSASİYET 5 KATINA ÇIKARILDI
            limited_x = max(-8, min(8, self.gyro_x))
            limited_y = max(-8, min(8, -self.gyro_y))

            # Ölçekleme faktörü 5 katına çıkarıldı
            point_x = self.center_x + (limited_x * 5)
            point_y = self.center_y + (limited_y * 5)

            # Nokta sınırları içinde kalsın
            max_radius = 65
            distance_from_center = ((point_x - self.center_x)**2 + (point_y - self.center_y)**2)**0.5
            if distance_from_center > max_radius:
                ratio = max_radius / distance_from_center
                point_x = self.center_x + (point_x - self.center_x) * ratio
                point_y = self.center_y + (point_y - self.center_y) * ratio
            
            # Su terazisi noktası
            Color(1, 0, 0)  # Kırmızı nokta
            Ellipse(pos=(point_x - 10, point_y - 10), size=(20, 20))
            
            # Merkez noktası
            Color(0, 1, 0)  # Yeşil merkez
            Ellipse(pos=(self.center_x - 4, self.center_y - 4), size=(8, 8))

class ColoredToggleButton(ToggleButton):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.background_normal = ''
        self.size_hint = (None, None)
        self.background_color = (0.545, 0.133, 0.196, 1)
        self.size = kwargs.get('size', (60, 40))
        self.default_color = (0.545, 0.133, 0.196, 1)
        self.active_color = (0.545, 0.133, 0.196, 1)
        with self.canvas.before:
            self.bg_color = Color(*self.default_color)
            self.bg_rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_graphics, size=self.update_graphics, state=self.update_color)

    def update_graphics(self, *args):
        self.bg_rect.pos = self.pos
        self.bg_rect.size = self.size

    def update_color(self, *args):
        if self.state == 'down':
            self.bg_color.rgba = self.active_color
        else:
            self.bg_color.rgba = self.default_color

class MainScreen(FloatLayout):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        with self.canvas.before:
            Color(0.351, 0.351, 0.351)
            Rectangle(size=Window.size, pos=(0, 0))
            
            # SERİAL PORT OPTİMİZASYONU
            self.serial_port = None
            possible_ports = [
                '/dev/tty.usbserial-120',
                '/dev/tty.usbserial-110',
                '/dev/tty.usbmodem14101',
                '/dev/cu.usbserial-120'
            ]
            
            for port in possible_ports:
                try:
                    self.serial_port = serial.Serial(port, 115200, timeout=0.01)  # HIZLI BAUD RATE
                    print(f"✅ Seri port bağlandı: {port}")
                    break
                except:
                    continue
            
            if not self.serial_port:
                print("❌ Seri port bulunamadı!")
            
            Color(0, 0, 0, 1)
            Rectangle(pos=(0,300), size=(800, 180))

        # BUFFER SİSTEMİ - Gelen verileri buffer'da topla
        self.data_buffer = deque(maxlen=50)  # Son 50 veriyi sakla
        self.serial_thread_running = True
        
        # Accelerometer max değerler için değişkenler
        self.max_accel_x = 0
        self.max_accel_y = 0
        self.max_accel_z = 0
        self.max_detector_x = 0
        self.max_detector_y = 0
        self.max_detector_z = 0

        # UI ELEMANLARI AYNI KALIYOR...
        YBP = 300
        self.add_widget(ArrowButton(direction='up', label_text='Z+', pos=(100, YBP + 50)))
        self.add_widget(ArrowButton(direction='down', label_text='Z-', pos=(100, YBP - 50)))
        self.add_widget(ArrowButton(direction='left', label_text='X-', pos=(20, YBP )))
        self.add_widget(ArrowButton(direction='right', label_text='X+', pos=(180, YBP )))
        self.add_widget(ArrowButton(direction='up', label_text='Y+', pos=(600, YBP + 75)))
        self.add_widget(ArrowButton(direction='down', label_text='Y-', pos=(600, YBP)))

        # Su terazisi
        self.terazi = GyroDisplay(size_hint=(None, None), size=(150, 150), pos=(310, 320))
        self.add_widget(self.terazi)

        RIBP = 650
        calibrate_btn = Button(
            text='Calibrate\nGyro',
            font_size=16,
            pos=(RIBP, 150),
            size_hint=(None, None),
            size=(100, 50),
            background_color=(0.2, 0.6, 0.2, 1)
        )
        calibrate_btn.bind(on_press=self.calibrate_gyro)
        self.add_widget(calibrate_btn)

        reset_max_btn = Button(
            text='Reset\nMax Values',
            font_size=15,
            pos=(RIBP, 90),
            size_hint=(None, None),
            size=(100, 50),
            background_color=(0.8, 0.2, 0.2, 1)
        )
        reset_max_btn.bind(on_press=self.reset_max_values)
        self.add_widget(reset_max_btn)

        # LABEL'LER
        self.max_platform_label = Label(
            text='MAX: pX=0  pY=0  pZ=0',
            font_size=16,
            pos=(280, 150),
            size_hint=(None, None),
            size=(300, 25),
            color=(1, 1, 0, 1),
            halign='left',
            text_size=(300, 25)
        )
        self.add_widget(self.max_platform_label)

        self.max_detector_label = Label(
            text='MAX: dX=0  dY=0  dZ=0',
            font_size=16,
            pos=(280, 125),
            size_hint=(None, None),
            size=(300, 25),
            color=(1, 1, 0, 1),
            halign='left',
            text_size=(300, 25)
        )
        self.add_widget(self.max_detector_label)

        self.temp_label = Label(
            text='TEMPERATURE: --°C',
            font_size=20,
            pos=(50, 340 + 2*30),
            size_hint=(None, None), size=(300, 30), color=(1, 1, 1, 1),
            halign='left', valign='middle', text_size=(300, 30)
        )
        self.add_widget(self.temp_label)

        self.humidity_label = Label(
            text='HUMIDITY: --%',
            font_size=20,
            pos=(50, 340+ 1*30),
            size_hint=(None, None), size=(300, 30), color=(1, 1, 1, 1),
            halign='left', valign='middle', text_size=(300, 30)
        )
        self.add_widget(self.humidity_label)

        self.distance_label = Label(
            text='DISTANCE: --cm',
            font_size=20,
            pos=(50, 340),
            size_hint=(None, None), size=(300, 30), color=(1, 1, 1, 1),
            halign='left', valign='middle', text_size=(300, 30)
        )
        self.add_widget(self.distance_label)

        self.detector_label = Label(
            text=' dX=0  dY=0  dZ=0', font_size=20, pos=(580, 310 + 0*30),
            size_hint=(None, None), color=(1, 1, 1, 1)
        )
        self.add_widget(self.detector_label)

        self.platform_label = Label(
            text='  pX=0  pY=0  pZ=0', font_size=20, pos=(580, 310 + 1*30),
            size_hint=(None, None), color=(1, 1, 1, 1)
        )
        self.add_widget(self.platform_label)

        self.add_widget(Label(
            text='ACCELEROMETER', font_size=20, pos=(580, 330 + 2*30),
            size_hint=(None, None), color=(1, 1, 1, 1)
        ))

        # Speed label ve hız göstergesini birleştir, sola ortala
        speed_label = Label(
            text="Speed: min",
            font_size=20,
            pos=(20, 55),
            size_hint=(None, None),
            size=(140, 40),
            color=(1, 1, 1, 1),
            halign='left',
            text_size=(140, 40)
        )
        self.speed_label = speed_label
        self.add_widget(speed_label)

        # 5 adet hız butonu
        self.mult_buttons = []
        speed_options = [("MİN", 20), ("%25", 85), ("%50", 150), ("%75", 215), ("MAX", 280)]
        for idx, (label, xpos) in enumerate(speed_options):
            btn = ColoredToggleButton(
                text=label,
                size=(60, 40),
                pos=(xpos, 5),
                font_size=20,
                group="mult"
            )
            btn.bind(on_press=self.on_mult_button)
            self.mult_buttons.append(btn)
            self.add_widget(btn)
        self.mult_buttons[0].state = 'down'

        axis_labels = ['Unlock X', 'Unlock Y', 'Unlock Z']
        self.axis_buttons = []
        for i, label in enumerate(axis_labels):
            axis_btn = ColoredToggleButton(
                text=label,
                size=(100, 40),
                pos=(RIBP, 260 + i * 80),
                font_size=18
            )
            axis_btn.bind(state=self.on_axis_toggle)
            self.axis_buttons.append(axis_btn)
            self.add_widget(axis_btn)

        self.lock_status_labels = []
        axis_names = ['X', 'Y', 'Z']
        for i, axis in enumerate(axis_names):
            lbl = Label(
                text=f"{axis}: unlocked",
                font_size=16,
                pos=(RIBP, 238 + i * 80),
                size_hint=(None, None),
                size=(100, 30),
                color=(1, 1, 1, 1),
                halign='center',
                text_size=(100, 30)
            )
            self.lock_status_labels.append(lbl)
            self.add_widget(lbl)

        # THREAD İLE SERİAL OKUMA BAŞLAT
        if self.serial_port:
            self.serial_thread = threading.Thread(target=self.serial_read_thread, daemon=True)
            self.serial_thread.start()
        
        # VERİ İŞLEME TIMER'I - Daha hızlı
        Clock.schedule_interval(self.process_serial_data, 1/60)  # 60 FPS

    def serial_read_thread(self):
        """THREAD: Sürekli serial porttan veri oku"""
        buffer = ""
        while self.serial_thread_running:
            try:
                if self.serial_port and self.serial_port.in_waiting:
                    chunk = self.serial_port.read(self.serial_port.in_waiting).decode('utf-8', errors='ignore')
                    buffer += chunk
                    
                    # Satır satır ayır
                    while '\n' in buffer:
                        line, buffer = buffer.split('\n', 1)
                        line = line.strip()
                        if line and line.startswith('{'):
                            self.data_buffer.append(line)
            except Exception as e:
                print(f"Serial okuma hatası: {e}")
                Clock.schedule_once(lambda dt: None, 1)  # 1 saniye bekle

    def process_serial_data(self, dt):
        """Ana thread: Buffer'daki verileri işle"""
        processed_count = 0
        max_per_frame = 5  # Frame başına maksimum işlem
        
        while self.data_buffer and processed_count < max_per_frame:
            try:
                line = self.data_buffer.popleft()
                data = json.loads(line)
                
                # HIZLI VERİ İŞLEME - Sadece gerekli güncellemeler
                self.update_sensor_data(data)
                processed_count += 1
                
            except json.JSONDecodeError:
                processed_count += 1
                continue
            except Exception as e:
                print(f"Veri işleme hatası: {e}")
                processed_count += 1

    def update_sensor_data(self, data):
        """Sensör verilerini hızlı güncelle"""
        try:
            # Temel sensörler
            if 'temperature_c' in data:
                self.temp_label.text = f"TEMPERATURE: {data['temperature_c']:.1f}°C"
            if 'humidity' in data:
                self.humidity_label.text = f"HUMIDITY: {data['humidity']:.1f}%"
            if 'distance_cm' in data:
                self.distance_label.text = f"DISTANCE: {data['distance_cm']:.1f} cm"
            
            # KALMAN FİLTRE - Su terazisi
            if 'kalman' in data:
                k = data['kalman']
                self.terazi.update_gyro_data(k['roll'], k['pitch'])
            
            # DETECTOR - Raw sensors
            if 'raw_sensors' in data and 'accel' in data['raw_sensors']:
                a = data['raw_sensors']['accel']
                self.detector_label.text = f"dX={a['x']:.2f}  dY={a['y']:.2f}  dZ={a['z']:.2f}"
                
                # Max değerler
                if abs(a['x']) > abs(self.max_detector_x):
                    self.max_detector_x = a['x']
                if abs(a['y']) > abs(self.max_detector_y):
                    self.max_detector_y = a['y']
                if abs(a['z']) > abs(self.max_detector_z):
                    self.max_detector_z = a['z']
                
                self.max_detector_label.text = f"MAX: dX={self.max_detector_x:.2f}  dY={self.max_detector_y:.2f}  dZ={self.max_detector_z:.2f}"
            
            # PLATFORM - ADXL345
            if 'adxl345' in data:
                d = data['adxl345']
                self.platform_label.text = f"pX={d['x']:.2f}  pY={d['y']:.2f}  pZ={d['z']:.2f}"
                
                # Max değerler
                if abs(d['x']) > abs(self.max_accel_x):
                    self.max_accel_x = d['x']
                if abs(d['y']) > abs(self.max_accel_y):
                    self.max_accel_y = d['y']
                if abs(d['z']) > abs(self.max_accel_z):
                    self.max_accel_z = d['z']

                self.max_platform_label.text = f"MAX: pX={self.max_accel_x:.2f}  pY={self.max_accel_y:.2f}  pZ={self.max_accel_z:.2f}"
        
        except Exception as e:
            pass  # Sessizce hatayı atla

    def reset_max_values(self, instance):
        """Maksimum değerleri sıfırla"""
        self.max_accel_x = 0
        self.max_accel_y = 0
        self.max_accel_z = 0
        self.max_detector_x = 0
        self.max_detector_y = 0
        self.max_detector_z = 0
        
        self.max_platform_label.text = 'MAX: pX=0  pY=0  pZ=0'
        self.max_detector_label.text = 'MAX: dX=0  dY=0  dZ=0'

    def calibrate_gyro(self, instance):
        """Gyroscope'u kalibre et"""
        instance.text = "Calibrating..."
        instance.background_color = (0.8, 0.8, 0.2, 1)
        self.send_to_arduino("CALIBRATE")
        Clock.schedule_once(lambda dt: self.reset_calibrate_button(instance), 3)

    def reset_calibrate_button(self, button):
        button.text = "Calibrate\nGyro"
        button.background_color = (0.2, 0.6, 0.2, 1)

    def on_mult_button(self, instance):
        self.speed_label.text = f"Speed: {instance.text}"
        for btn in self.mult_buttons:
            btn.state = 'normal'
        instance.state = 'down'
        self.send_to_arduino(f"S{instance.text}")

    def on_axis_toggle(self, instance, value):
        if value == 'down':
            axis = instance.text.replace("Unlock ", "").replace("Lock ", "")
            instance.text = f"Lock {axis}"
            self.send_to_arduino(f"l{axis}")
        else:
            axis = instance.text.replace("Lock ", "").replace("Unlock ", "")
            instance.text = f"Unlock {axis}"
            self.send_to_arduino(f"ul{axis}")

    def send_to_arduino(self, message):
        try:
            if self.serial_port:
                self.serial_port.write((message + '\n').encode())
        except Exception as e:
            print(f"Serial gönderme hatası: {e}")

class MainApp(App):
    def build(self):
        return MainScreen()

if __name__ == '__main__':
    MainApp().run()

